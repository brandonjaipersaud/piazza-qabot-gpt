import sys 
sys.path.append("../")

import argparse
from argparse import Namespace, ArgumentParser

import getpass
import openai 

import logging
from logging import debug, info, error


from nptyping import NDArray, Int, Shape
from typing import Dict, List, Tuple, Union

from piazza_api import Piazza
from piazza_api_utils.my_piazza_api import MyNetwork

from piazza_api_utils.utils import *
from csv_manipulation.csv_utils import *

# from deployment.config_311 import general_params, database_params, classify_model_params, answer_model_params
from openai_interface.prompt_gpt3 import prompt_gpt3

# where the prompts are stored
from experiments.prompts import *

import yaml

from dotenv import load_dotenv
load_dotenv()

# Format of answer that will be posted to Piazza
FOLLOWUP_FORMAT = """
<strong>The following answers were generated by GPT3 to help you formulate an answer. If you found any of these answers helpful/not helpful, please respond with: “answer x, good” or “answer x, bad”.</strong>
                  
<strong>ANSWER 1:</strong>
{}

<strong>ANSWER 2:</strong>
{}
"""

DB_SCHEMA = "question_id,question_title,question_content,classification,answer(s),feedback"

PROMPT_PATH = "../question_classification/prompts.yaml"


def usage():
    print("Usage: python run_bot.py <path to config yaml file>")



def classify_question(question, save=False) -> str:

    global general_params, database_params, classify_model_params, answer_model_params, prompts

    prompt = classify_model_params["prompt"]
    prompt = prompts[prompt]
    prompt = prompt.format(question)

    response = prompt_gpt3(prompt, config=classify_model_params)
    debug(response)

    question_category = response["choices"][0]["text"].strip()
    debug(f'question category: {question_category}')

    return question_category
        

def answer_question(question:str) -> list:
    global general_params, database_params, classify_model_params, answer_model_params, prompts

    prompt = answer_model_params["prompt"]
    prompt = prompts[prompt]
    prompt = prompt.format(question)


    response = prompt_gpt3(prompt, config=answer_model_params)
    debug(response)

    choices = response["choices"]
    answers = []

    for c in choices:
        answers.append(c["text"])

    debug(f"Answers: {answers}")
    return answers

    

def answer_questions(user_profile:dict, course:MyNetwork, question_db:pd.DataFrame, db_path:str):

    global general_params, database_params, classify_model_params, answer_model_params, prompts


    # Find the user ID of PiazzaBot. Used to ensure we dont respond to posts we've already responded to
    piazzabot_id = user_profile['user_id']

    info(f'Piazzabot name is: {user_profile["name"]}')
    # info(f'Piazzabot id is: {piazzabot_id}')
    info(f'Courseid: {course._nid}\n\n')
    
    assert(piazzabot_id != None)


    # Grab posts that have not already been responded to by an instructor or student-endorsed answer (or one that is already in the db)
    posts = course.iter_all_posts(piazzabot_id, limit=general_params["posts-fetch-size"], skip_answered=True, \
                                    db=question_db, db_path=db_path)


    # state to track. if adding more state, change this to a state dict. occasionally log info.
    answered_questions = 0  # Num of questions that the bot has responded to

    # question_ids:pd.Series = question_db["question_id"]

    for p in posts:
        q_id = p["nr"]
        q_title = p['history'][0]['subject']
        q_content = p['history'][0]['content']
        info(f"\n\n{'-' * 30} QUESTION {q_id} START {'-' * 30}\n\n")

        if db_path:
            # check if question id in db. If so, ignore.
            if q_id in question_db["question_id"].values:
                info(f'Question: {q_id} already in DB. Skipping.\n')
                continue

            else:
                # add new entry to db 
                info(f'Adding question: {q_id} to DB\n')
                #question_db = pd.concat(question_db, q_id)
               
                question_db.loc[len(question_db)] = [q_id, None, None, None, None, None]
                

        # filter html tags
        q_title = strip_tags(q_title).strip()
        q_content = strip_tags(q_content).strip()

        question_db.loc[question_db["question_id"] == q_id, "question_title"] = q_title
        question_db.loc[question_db["question_id"] == q_id, "question_content"] = q_content


        info("=" * 40)
        info(f'Title: {q_title}')
        info(f'Content: {q_content}')
        info("-" * 40)
        info("\n")

        question = merge_title_and_content(q_title, q_content)

        # question classification
        question_category = classify_question(question)

        question_db.loc[question_db["question_id"] == q_id, "classification"] = question_category

        if not question_category == "conceptual":
            question_db.to_csv(db_path, index=False)
            debug(f"Skipping question {q_id}\n")
            continue

        # question answering
        debug(f"Answering question {q_id}\n")

        answers = answer_question(question)
        question_db.loc[question_db["question_id"] == q_id, "answer(s)"] = str(answers)
        question_db.to_csv(db_path, index=False)

        followup = FOLLOWUP_FORMAT.format(answers[0], answers[1])

        #Post followup
        course.create_followup(p, followup)

        answered_questions += 1

        # add 2.5s delay b/w fetching posts to avoid throttling
        time.sleep(2.5)


        info(f'Bot finished answering questions.')
        info(f'# of questions answered: {answered_questions}')


if __name__ == "__main__":

    if len(sys.argv) != 2:
        usage()
        exit(-1)


    config_path = sys.argv[1]
    with open(config_path, 'r') as f:
        with open(PROMPT_PATH, 'r') as p:
            global general_params, database_params, classify_model_params, answer_model_params, prompts

            config = yaml.safe_load(f)
            prompts = yaml.safe_load(p)

            general_params = config["general_params"]
            database_params = config["database_params"]
            classify_model_params = config["classify_model_params"]
            answer_model_params = config["answer_model_params"]

        
            # print(prompts[prompt].format("hello world123"))
            
    # stream = open(config, 'r')
    # dictionary = yaml.load(stream)
    # for key, value in dictionary.items():
    #     print (key + " : " + str(value))



    if not general_params["openai-key-path"]:
        openai_key = getpass.getpass(prompt="OpenAI API Key:")
    else:
        with open(general_params["openai-key-path"]) as f:
            openai_key = f.readline()

    openai.api_key = openai_key

    piazza_pwd = os.environ.get('PIAZZA_PASSWORD')

    if not piazza_pwd:
        piazza_pwd = getpass.getpass(prompt="Piazza Password:")


    user_profile, course = login(email=general_params["piazza-email"], password=piazza_pwd, courseid=general_params["piazza-courseid"], echo=True)
    
    
    # log params before answering questions
    #timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")

    log_prefix = general_params["log-prefix"]

    # ensure no overwrite
    logging.basicConfig(filename=f'logs/{log_prefix}.log', filemode='a', level=logging.DEBUG, format='[%(asctime)s] [%(levelname)s] - %(message)s')
    # log to file and stderr
    logging.getLogger().addHandler(logging.StreamHandler(sys.stderr))

    info(f"{'-' * 40}NEW RUN{'-' * 40}")

    
    try:
        question_db = pd.read_csv(database_params["path"])
    except (FileNotFoundError): 
        error("Database path does not exist. Creating new db.")
        with open(database_params["path"], 'w') as f:
            f.write(DB_SCHEMA)
        question_db = pd.read_csv(database_params["path"])
    
    print(question_db.keys())

  

    info(f'General Params:\n\n{general_params}\n\n')
    info(f'Database Params:\n\n{database_params}\n\n')
    info(f'Classify Params:\n\n{classify_model_params}\n\n')
    info(f'Answer Params:\n\n{answer_model_params}\n\n')
    info(f'Prompts:\n\n{prompts}\n\n')


    answer_questions(user_profile, course, question_db, database_params["path"])

 